<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Horizontal centering</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
  <body>
    <h3>Horizontal centering</h3>
    <h4>Inline elements</h4>
    <p>
      How do you center an inline element?  As we recall, inline elements are positioned along the baseline, in the natural flow of the text or content. So for any individual inline element, there is no CSS property you can apply directly to cause this element to center. You may apply some padding evenly or unevenly to position its content relative to its own box. But that's not centering the element itself.<br><br>
      To center an inline element, we use the text-align property of its parent.   <br><br>
      p { text-align: center; } /* the text and any inline children of this element will be centered */ <br><br>
      If this isn't satisfactory, consider changing the element to be inline-block or block.
    </p>
    <h4>Block elements</h4>
    <p>
      block level elements take the width of their parent by default. If the element is the same width as its parent, it is already centered. So the first step is to limit the width of the element, second we set margin to auto: left and right margins will center the element.<br><br>
      div { width: 200px; margin: auto; }<br><br>
      There is a better way to achieve centering and its name is flexbox
    </p>
    <h3>position property</h3>
    <p>
      There are four properties which can be used to adjust or set the position of an element. Those properties are: left, top, right, and bottom. However using those properties by themselves will have no effect on any element: these properties only work when applied to positioned elements. And positioned elements are those that have had their position property changed from the default (static). <br>
      Position property governs how an element is positioned on the page and how it responds to the position adjusting properties, it has four different values it can take: static, relative, absolute, and fixed
    </p>
    <h5>Static {position: static; /* the default */}</h5>
    <p>
      It means that all elements follow the "flowing text"model of layout and the only properties influencing their position are margins, padding, and the display property ( block, inline or inline-block). Static elements ignore the positioning properties we read about earlier (left, top, right, and bottom).
    </p>
    <h5>Fixed {position: fixed}</h5>
    <p>
      A fixed positioned element respects the positioning properties (left, top, right, and bottom).  A fixed positioned element is positioned against the window rectangle (aka the viewport).  This means that fixed position elements will not scroll with the rest of the page.  Fixed position elements can easily "stick" to the side or bottom or top of the browser<br>
      <ul>
        <li>
          If an element is set to be position:fixed, but has no horizontal positioning property (that is, left or right), then it will be displayed in the flow exactly as it would have been.  Except, later, if left:0px;  is added (for example), then the element may jump to the left edge of the browser window. The same applies vertically. This is a bewildering behavior, as most users do not expect there to be a difference between left:0px and no left property at all. Therefore, for any fixed positioned element, the best practice is to ensure that one of the horizontal positioning properties (that is, left or right) and one of the vertical properties (top or bottom) are both set    
        </li>
        <li>
          Fixed positioned block level elements do not get the width of their parent, Their initial width is simply the width of their content
        </li>
        <li>
           when an element is fixed positioned, a given margin might be able to move the element but will not move any siblings, margins cannot be used to keep siblings "away".
        </li>
        <li>
           fixed positioned items can instead set the opposite positioning properties (like left and right) and leave the matching dimensional property (width) unspecified, the element will grow or shrink based on the size of the browser window
        </li>
      </ul>
    </p>    
    <h5>relative {position: relative}</h5>  
    <div>
      The relative value is exactly like static in that the "flowing text" model of layout is setting the initial position for the element (including margins and display). However, unlike static, elements with relative position respect the positioning  properties (left, top, right, and bottom), these properties will move the named edge of the element from its initial position: a value of top: 20px;  will move the top edge of the element 20 pixels further down the page
      <ul>
        <li>Items are moved independently of siblings.</li>
        <li>Opposite positioning properties (like left and right) cannot be used simultaneously.</li>
        <li>There are no automatic size adjustments.</li>
      </ul>
      The positioning properties (left, top, right, and bottom) adjust the placement of the element independently of its siblings.  What does this mean? Let's imagine we have a list and we want to move one of the items a little further down the page. Should we use margin-top to move it? Or position:relative in conjunction with the top property? The answer to this question depends on whether you want any of the other list items to move as well. If you want the siblings to move down as well, then use margin-top.<br>
      Margin-top:
      <ul>
        <li>One</li>
        <li>Two</li>
        <li id="Margin">Three</li>
        <li>Four</li>
        <li>Five</li>
      </ul>
      Relative:
      <ul>
        <li>One</li>
        <li>Two</li>
        <li id="Relative">Three</li>
        <li>Four</li>
        <li>Five</li>
      </ul>
      Block level elements take the width of their parent (when no width is specified) and when using left or right margins without having an explicit width, the browser will smartly size the element down for you to make it fit. This size adjustment does not happen when you use position:relative and the left or right positional properties. This is easily illustrated with an example. Below is a block level paragraph with a border applied to it.  When a margin-left is applied to it, the paragraph is made smaller and no part goes outside its parent.  But when it is position:relative and moved with the left property, it can leave the bounds of its parent, or go offscreen.
      <div id="fixed">
        <p id="autoadjustment">
            Dorothea was altogether captivated by the wide embrace of this conception.
        </p>
        <p id="noautoadjustment">
            Dorothea was altogether captivated by the wide embrace of this conception.
        </p>
      </div>
    </div>
    <h5>Absolute {position: absolute}</h5>  
    <div>
      An element that is positioned absolutely is taken out of the normal text "flow" that governs elements positioned statically or relatively, instead is positioned by the left, top, right, and/or bottom properties. The size or position of siblings have no effect on an absolutely positioned element that has some positioning properties set (left, top, etc.)
      
      <p id="margin">
        She bethought herself now of the condemned criminal. <q id="abs">What news have you brought about the sheep-stealer, uncle?</q>
      </p>
      <ul>
        <li>use both a horizontal and a vertical positioning property on every absolute element.</li>
        <li>Absolutely positioned elements do not contribute to size of the parent</li>
        <li>Absolute positioned block level elements do not get the width of their parent. </li>
        <li>Margins do not work the same, a given margin might be able to move the element but will not move any siblings</li>
        <li>Opposite properties can be used to size element. The element will grow or shrink based on the size of the ancestor it is positioning against.</li>
      </ul>
      <p>
        For an absolutely positioned element, where the left, top, etc. are calculated from depends upon the position property of the parent and grandparents of the element in question. If the parent of the element is a positioned element (meaning its position is set to anything except position:static), then an absolutely positioned child  is positioned relative to that parents rectangle (or grandparent, or great-grandparent, etc).  But if none of the parents are positioned elements, the child is positioned relative to the bounds of the document.  
      </p>

      <ul id="absolutetwo">
        <li>First <span>1</span></li>
        <li>Second <span>2</span></li>
        <li class="rel">Third <span>3</span></li>
        <li class="rel">Fourth <span>4</span></li>
      </ul>
    </div>
    <p>
      Two of the list items are position:relative, so the spans are positioned starting from their rectangle.  But two of the list items are position:static (the default), so the spans are moved up to the ul (which is also position:relative) where they overlap each other <br>
      If an element is set to be position:absolute but has no horizontal positioning property (that is, left or right), then it will be displayed in the flow exactly as it would have been, if left:0px;  were added (for example), then the element may jump to the left edge of the first parent/grandparent that is a positioned element. The same applies vertically. This is a bewildering behavior, as most users do not expect there to be a difference between left:0px and no left property at all. Therefore, for any absolutely positioned element, the best practice is to ensure that one of the horizontal positioning properties (that is, left or right) and one of the vertical properties (top or bottom) are set.
    </p>
    <p>
       one of the most useful default behaviors is that the height of a parent element is automatically extended to include all its children, its content. Designers working in CSS unconsciously lean on this fact as they plan layouts and adjust element positions. But this is not true for children that are positioned absolutely.  Absolutely positioned children do not contribute to the size of the parent element. A parent element that contains only absolutely positioned children will have a height of 0, has no "measurable" content and will behave as if it is empty. A consequence of this is that as a design starts to use absolute positioning, it may also have to start explicitly setting the dimensions of containers, which makes the overall design brittle and less adaptable.
    </p>
    <ul id="empty">
      <li>First </li>   
    </ul>


    <div class="fixed">This div element has position: fixed;</div>
  </body>
</html>
